---
title: "Avolve Part-3"
date: '2024-04-06'
lastmod: '2024-04-06'
tags: ['Avolve', 'Neural Network', 'Genetic Algorithm']
draft: false
summary: "基于神经网络和遗传算法实现的模拟进化 Part-3"
authors: ['default']
---

<div className="border-solid border-2 border-surface0 dark:border-surface0-dark p-2 bg-base dark:bg-base-dark mt-5">
  <TOCInline toc={props.toc} asDisclosure />
</div>

这是 Avolve 系列的第三部分，我们使用 **神经网络** 和 **遗传算法** 编写模拟进化代码：

在上一篇文章中，我们实现了一个简单的前馈神经网络，它可以将数字传播到其随机化的层中。这是我们努力创建一个运作良好的大脑的第一个里程碑。

然而，随机性只能帮助我们到这里。在大多数情况下，进化是关于做出小的、渐进的变化，使系统随着时间变得更好。这样，我们创建的大脑开始积累知识并按我们期望的方式运作（只要吃到食物，小鸟们！）。

但是我们如何训练一堆浮点数呢？

## 计划

稍后，我们将通过在 rust 中实现一个遗传算法来学习它是如何工作的。我们将深入探讨[选择](https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)) (Selection)、[交叉](https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)) (Crossover) 和[突变](https://en.wikipedia.org/wiki/Mutation_(genetic_algorithm)) (Mutation) 如何结合在一起，并允许计算机看似凭空找到复杂的解决方案。

我们将尽量保持通用性，也就是说，我们不会将特定的选择或交叉算法硬编码到代码中，而是使用 `trait` 来创建一个库，甚至可以发布到 [crates.io](https://crates.io/) 上！

就像之前一样，今天我们将探讨 rust 语法的各种复杂之处，重点放在术语上。

希望在这篇文章结束时你可以说：我可以自己实现这一切！

## 简介

首先，让我们回顾一下遗传算法的工作原理以及这个项目的目的。

我们的问题是，我们有一个对象，一个神经网络——它由大量参数定义。它们的数量如此之多，即使是对于最小的网络，我们也不可能在有生之年穷尽它们的所有组合。

<Note>
  所有可能的参数通常被称为**搜索空间 (Search Space)**；一个博学的人可能会说：我们的问题的搜索空间非常巨大，然后他就逃跑了。
</Note>

我们可以模仿自然的方式：如果我们从一堆随机的 **次优 (Suboptimal)** 解开始，我们可以尝试改进它们，随着时间的推移，逐渐获得更好的答案。

模拟所有这些进化机制的方法之一是遗传算法——它从一堆随机的解决方案（一个种群）开始，然后利用交叉和突变来改进它们，利用适应度函数评估到目前为止找到的解决方案（个体）：

<center>
  <Image alt="遗传算法概述；从顶部开始顺时针方向：(1) 使用适应度函数估计当前解决方案，(2) 执行交叉和突变，(3) 在新的、改进的种群上重新开始整个过程" src="https://pic.imgdb.cn/item/6610bbc268eb93571339b797.png" width={230} height={189} />
</center>

<Note>
  由于遗传算法涉及到处理随机数，它是一种<a href="https://en.wikipedia.org/wiki/Randomized_algorithm" target="blank" style={{ color: `#8e91f2` }}>随机化算法</a>的例子。<br style={{ marginBottom: '0.5em' }} />

  随机化算法通过牺牲准确性来换取性能。它并不总是返回最佳答案，但通常会得到 Pretty Close Pretty Cheaply ® 的结果。<br style={{ marginBottom: '0.5em' }} />
</Note>

蔬菜供应商才不希望你知道这一点，其实有一个基于遗传算法的简单程序就可以帮助你成为一个胡萝卜大亨：

```plain-text
10  go to your garden
20  sow a few random carrots
30  wait for those carrots to sprout
40  choose the best carrot-children and sow them
50  goto 30

in this world:
- population = carrots
- individual = carrot
- mutation & crossover = happen automatically (free labor!)
- fitness function = your eyes & brain
```

到现在为止，这些术语对你来说应该已经很熟悉了。我们在第一篇文章中已经介绍了遗传算法的基础知识；到本文结束时，你将已经回答了以下问题：

 - 但是你如何选择个体呢？肯定有一千种方法可以做到！（是的，确实有）
 - 但是你如何表示它们的基因组呢？肯定有一千种方法可以做到！（是的，确实有）
 - 但是你如何在 rust 中实现它呢？你承诺它将在浏览器中工作！（是的，它会的）

## 实现框架

我们首先需要在工作区中创建第二个 crate：

```bash
cargo new genetic-algorithm --name genetic-algorithm --lib
```

那是由 `Cargo` 为我们创建的不错的 `lib.rs` 文件。让我们用一个入口点来替换它：

```rust:genetic-algorithm/src/lib.rs {1} showLineNumbers
pub struct GeneticAlgorithm;
```

我们的遗传算法将只提供一个功能——有时称为**迭代 (Iterate)**，有时称为**步骤 (Step)**或**过程 (Process)**。我扔了一枚硬币并决定：

```rust:genetic-algorithm/src/lib.rs {1-5} showLineNumbers
impl GeneticAlgorithm {
    pub fn evolve(&self) {
        todo!()
    }
}
```

我们正在进化什么？当然是鸟的种群！

```rust:genetic-algorithm/src/lib.rs showLineNumbers
impl GeneticAlgorithm {
    pub fn evolve(&self, population: &[???]) -> Vec<???> {
        todo!()
    }
}
```

我们实际的问题将依赖于神经网络，但由于我们希望这个库是通用的，我们不能强制它接受硬编码的 `NeuralNetwork`。相反，我们可以引入一个类型参数：

```rust:genetic-algorithm/src/lib.rs {2} showLineNumbers
impl GeneticAlgorithm {
    pub fn evolve<I>(&self, population: &[I]) -> Vec<I> {
        todo!()
    }
}
```

<Note>
  `I` 代表个体，至于 Rust 的术语：

  ```rust
  // visibility  generics   _ function parameters
  // |          _|     ____|  (or just "parameters")
  // |         |      |
  // v-v       v-----vv----------v
     pub fn foo<'a, T>(bar: &'a T) { /* ... */ }
  //            ^^  ^  ^--------^
  //            |   |  |
  //            |   |  function parameter
  //            |   |  (or just "parameter")
  //            |   type parameter
  //            lifetime parameter
  ```
  <br style={{ marginBottom: '0.5em' }} />

  <center><a href="https://doc.rust-lang.org/reference/items/functions.html" target="blank" style={{ color: `#8e91f2` }}>https://doc.rust-lang.org/reference/items/functions.html</a></center>
  <br style={{ marginBottom: '0.5em' }} />

  如果你想向别人描述这个签名，你会说：
  <br style={{ marginBottom: '0.5em' }} />

  `public` 函数 `foo` 是泛型的，泛型参数包括生命周期 `'a` 和类型 `T`，它接受一个名为 `bar` 的参数，该参数是对 `T` 类型的引用。
  <br style={{ marginBottom: '0.5em' }} />

  这是函数的定义，另一方面，你 **调用 (Invoke)** 函数的地方被称为 **调用点 (Call Site)**，你在那里指定的值称为 **参数 (Arguments)**：

  ```rust
  // v-----------------------v call site
     foo::<'static, f32>(&1.0);
  //       ^-----^  ^-^  ^--^
  //       |        |    |
  //       |        |    function argument
  //       |        |    (or just "argument")
  //       |        type argument
  //       lifetime argument
  ```
  <br style={{ marginBottom: '0.5em' }} />

  大多数这种术语（例如 `argument` 和 `parameter` 之间的区别）在所有编程语言中都是通用的，因此值得记住。
</Note>

吸取过去的教训，让我们不要忘记前置条件：

```rust:genetic-algorithm/src/lib.rs {3} showLineNumbers
impl GeneticAlgorithm {
    pub fn evolve<I>(&self, population: &[I]) -> Vec<I> {
        assert!(!population.is_empty());

        /* ... */
    }
}
```

至于算法本身的框架，大致如下：

```rust:genetic-algorithm/src/lib.rs {5-12} showLineNumbers
impl GeneticAlgorithm {
    pub fn evolve<I>(&self, population: &[I]) -> Vec<I> {
        /* ... */

        (0..population.len())
            .map(|_| {
                // TODO selection
                // TODO crossover
                // TODO mutation
                todo!()
            })
            .collect()
    }
}
```

## 实现 Selection

此时，在循环内部，我们必须选择两个个体。它们将成为父母，为我们「生」出一个数字后代。

选择个体被称为遗传算法的[选择阶段 (Selection Stage)](https://en.wikipedia.org/wiki/Selection_(genetic_algorithm))，它应满足以下两个性质：

 - 每个个体被选中的概率都应该是非零的
 - 一个适应度得分更高的个体平均来说应该比适应度得分更低的个体更频繁地被选中

因为我们必须计算适应度分数，让我们首先考虑一下如何编写计算适应度的函数。我们有两种独特的方法：

1. 将适应度函数作为个体的参数：

```rust:genetic-algorithm/src/lib.rs showLineNumbers
impl GeneticAlgorithm {
    pub fn evolve<I>(
        &self,
        population: &[I],
        evaluate_fitness: &dyn Fn(&I) -> f32,
    ) -> Vec<I> {
        /* ... */
    }
}
```

2. 将适应度分数作为个体的属性：

```rust:genetic-algorithm/src/lib.rs {1-3, 6-11} showLineNumbers
pub trait Individual {
    fn fitness(&self) -> f32;
}

impl GeneticAlgorithm {
    pub fn evolve<I>(&self, population: &[I]) -> Vec<I>
    where
        I: Individual,
    {
        /* ... */
    }
}
```

第一种方法：

 - 允许为一种个体提供许多不同的适应度函数，这对某些人可能会很有用（不过对我们来说并没有什么用）
 - 需要在每次调用 `.evolve()` 时指定适应度函数，这感觉有点笨拙

第二种方法：

 - 允许将所有与个体相关的属性封装到一个单一的 `trait` 中，让用户更容易发现他们需要提供的内容
 - 指定不同的适应度函数是可能的，但有点棘手

我的直觉告诉我引入一个 `trait`（正如你稍后会看到的，无论如何我们都需要这样一个 trait），所以就是方法二了。

至于选择方法，我们将使用一种被称为[适应度比例选择 (Fitness Proportionate Selection)](https://www.tutorialspoint.com/genetic_algorithms/genetic_algorithms_parent_selection.htm)（也叫做**轮盘赌选择 (Roulette Wheel Selection)**）的算法，因为它很容易理解。为了理解它的工作原理，让我们想象一下我们有以下三个个体：

| Individual | Fitness score | Fitness score % |
|:-----------|:--------------|:----------------|
| A          | 3             | $\frac{3}{1+2+3} =\frac{1}{2} =50\%$ |
| B          | 2             | $\frac{2}{1+2+3} =\frac{1}{3} =33\%$ |
| C          | 1             | $\frac{1}{1+2+3} =\frac{1}{6} =16\%$ |

如果我们把它们都放在一个轮盘上，或者说，无论是什么饼图都可以。每个个体都得到一个轮盘的部分，这个部分的大小与它们的适应度分数在整个种群中的比例相等：

<center>
  <Image alt="一个饼图（它就像一个轮盘），用来说明上面表格中的个体" src="https://pic.imgdb.cn/item/6610dc0368eb9357137ec997.png" width={96} height={85} />
</center>









